## 聊天室(多线程版本)

---



![聊天室简单结构图](chat_room\mig\结构图.png)

:ballot_box_with_check:上图中**Server**服务器就充当一个中转站角色，当**Client**客户端通过程序传送到服务器时，服务器再将客户端发送来的信息转发的某个或多个客户端，进而实现实时通信的目的

---

### 实现所需要的技术：

#### 1.Socket：客户端类

```java
//根据指定ip和端口号创建套接字并连接到远程服务器
public Socket(String host,int post);
//返回此套接字的输入流
public InputStream getInputStream();
//返回此套接字的输出流
public OutputStream getOutputStream();
```

#### 2.ServerSocket：服务器Socket类

```java
//在本机根据指定端口号创建服务器，IP默认使用本机IP
public ServerSocket(int port);
//侦听并接收连接到本服务器的客户端，此方法会一直阻塞，直达有客户连接成功，返回此连接
public Socket accept();
```

#### 具体实现方法

当开启服务器时，服务器就会创建一个Socket对象。当进行客户端与服务器之间信息传递时，都是通过一个数据通道来实现的，而这里的通道就是通过Socket对象的不断写入与读取来实现的。

**具体步骤**

1. 服务器实例化一个SeverSocket对象，用于服务器的端口通信
2. 服务器调用ServerSocket类的accept()方法，阻塞式的等待客户端进行连接到当前所设置的端口
3. 当服务器阻塞式的等待连接，而这时客户端实例化一个socket对象，并且根据指定的ip地址和端口号去向服务器请求连接
4. socket类的构造函数尝试将客户端连接到指定服务器与端口号。当通信被成功连接，就可以通过该通道进行数据的传输。
5. 服务器段的accept()方法返回一个socket引用，该引用与客户端的socket是相互连接的。
6. 当客户端与服务器连接成功是，它们之间的数据传输就是通过I/O流行输入输出，而且客户端与服务器都有其对应的输入输出流进行连接的，这里注意，客户端与服务器的输入输出流都是各自私有的，二者的使用是要分开的。

- 每当有一个客户通过socket与服务器要建立连接时，服务器就会通过accept()侦听成功，并且会返回连接到的socket，这样就会形成一条通道，将客户端与服务连接起来，通过这条通道就可以将数据进行接收与发送。



#### 其他技术

**1.采用concurrentHashMap存储所有连接到服务器的客户端信息**

- 在注册用户时，用户名和其对应的socket可以用**Key-Value**模型进行存储，这样不仅方便存储，而且当进行群聊时，只需要将哈希表遍历转发即可，在私聊时也可以通过用户名直接找到其对应的socket进行信息传输。在选择哈希表时，要使用**ConcurrentHashMap**进行数据存储，使用该哈希表进行存储时，当有用户名相同的用户同时注册时，就避免的线程安全问题，效率也提高了很多。当然也可以使用其它的哈希表进行存储，但是要手动的进行同步处理，效率会大大降低。

**2.使用线程池来规定客户端数量**

- 在使用多线程实现聊天室时，要实现Runnable接口来处理每一个客户端的请求，在程序当中使用了线程池来规定客户端的最大数量

**3.使用内部类具体处理客户端请求**

- 使用内部类方便和外部类私有属性访问，实现封装

### 实现功能

- 用户注册
- 私聊
- 群聊

### 源代码

**客户端**

- [客户端源代码](https://github.com/Dyson-x/chat_room/blob/master/MultiThreadClient.java)

**服务端**

- [服务端源代码](https://github.com/Dyson-x/chat_room/blob/master/MultiThreadClient.java)

